tosca_definitions_version: cloudify_dsl_1_2

description: >
  This blueprint defines a vSphere VM created using Cloudify's vSphere plugin
  and a simple web server started using Cloudify's script plugin.

imports:
  - http://www.getcloudify.org/spec/cloudify/3.4m4/types.yaml
  - http://www.getcloudify.org/spec/vsphere-plugin/2.0/plugin.yaml
  - http://www.getcloudify.org/spec/diamond-plugin/1.3.2/plugin.yaml

inputs:
  webserver_port:
    description: The HTTP web server port
    default: 8080
  agent_user:
    description: User name used when SSH-ing into the started machine
    default: centos
  server_name:
    description: The name of the deployed VM. This will have a suffix based on the cloudify node ID.
    default: hello-world
  template:
    description: The template to deploy the hello-world VM from.
  server_cpus:
    description: How many CPUs the hello world VM should have.
    default: 1
  server_memory:
    description: How much memory the hello world VM shoudl have, in MB
    default: 512
  dns_servers:
    description: Which DNS servers to use
    default:
      - '8.8.8.8'
      - '8.8.4.4'
  network_name:
    description: >
      Which vSphere network to attach the server to.
      This network must be able to reach both the manager and the internet.
  switch_distributed:
    description: Whether the vSphere network for this VM is distributed (true) or not (false).
  use_dhcp:
    description: Whether or not to use DHCP for IP address assignment.
    default: true
  network_cidr:
    description: The network CIDR (e.g. 192.0.2.0/24), if DHCP is not in use.
    default: ''
  network_gateway:
    description: The network gateway (e.g. 192.0.2.1), if DHCP is not in use.
    default: ''
  network_ip:
    description: The IP address of this VM on the network (e.g. 192.0.2.101), if DHCP is not in use.
    default: ''

node_templates:
  vm:
    type: cloudify.vsphere.nodes.Server
    properties:
      server:
        name: { get_input: server_name }
        template: { get_input: template }
        cpus: { get_input: server_cpus }
        memory: { get_input: server_memory }
      cloudify_agent:
        user: { get_input: agent_user }
      networking:
        domain: ''
        dns_servers: { get_input: dns_servers }
        connect_networks:
          - management: true
            external: true
            name: { get_input: network_name }
            switch_distributed: { get_input: switch_distributed }
            use_dhcp: { get_input: use_dhcp }
            network: { get_input: network_cidr }
            gateway: { get_input: network_gateway }
            ip: { get_input: network_ip}

    interfaces:
      ###########################################################
      # We are infact telling cloudify to install a diamond
      # monitoring agent on the server.
      #
      # (see https://github.com/BrightcoveOS/Diamond)
      ###########################################################
      cloudify.interfaces.monitoring_agent:
          install:
            implementation: diamond.diamond_agent.tasks.install
            inputs:
              diamond_config:
                interval: 1
          start: diamond.diamond_agent.tasks.start
          stop: diamond.diamond_agent.tasks.stop
          uninstall: diamond.diamond_agent.tasks.uninstall
      cloudify.interfaces.monitoring:
          start:
            implementation: diamond.diamond_agent.tasks.add_collectors
            inputs:
              collectors_config:
                  CPUCollector: {}
                  MemoryCollector: {}
                  LoadAverageCollector: {}
                  DiskUsageCollector:
                    config:
                      devices: x?vd[a-z]+[0-9]*$
                  NetworkCollector: {}

  http_web_server:
    type: cloudify.nodes.WebServer
    properties:
      port: { get_input: webserver_port }
    relationships:
      - type: cloudify.relationships.contained_in
        target: vm
    interfaces:
      cloudify.interfaces.lifecycle:
        configure: scripts/configure.sh
        start: scripts/start.sh
        stop: scripts/stop.sh

outputs:
  http_endpoint:
    description: Web server's external endpoint
    value: { concat: ['http://', { get_attribute: [vm, public_ip] },
                      ':', { get_property: [http_web_server, port] }] }
